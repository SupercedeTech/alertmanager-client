{-
   Alertmanager API

   API of the Prometheus Alertmanager (https://github.com/prometheus/alertmanager)

   OpenAPI Version: 3.0.1
   Alertmanager API API version: 0.0.1
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Network.Alertmanager.OpenAPI.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Network.Alertmanager.OpenAPI.Model where

import Network.Alertmanager.OpenAPI.Core
import Network.Alertmanager.OpenAPI.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Active
newtype Active = Active { unActive :: Bool } deriving (P.Eq, P.Show)

-- ** Alerts
newtype Alerts = Alerts { unAlerts :: [PostableAlert] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Filter
newtype Filter = Filter { unFilter :: [Text] } deriving (P.Eq, P.Show)

-- ** Inhibited
newtype Inhibited = Inhibited { unInhibited :: Bool } deriving (P.Eq, P.Show)

-- ** Receiver2
newtype Receiver2 = Receiver2 { unReceiver2 :: Text } deriving (P.Eq, P.Show)

-- ** SilenceId
newtype SilenceId = SilenceId { unSilenceId :: Text } deriving (P.Eq, P.Show)

-- ** Silenced
newtype Silenced = Silenced { unSilenced :: Bool } deriving (P.Eq, P.Show)

-- ** Unprocessed
newtype Unprocessed = Unprocessed { unUnprocessed :: Bool } deriving (P.Eq, P.Show)

-- * Models


-- ** Alert
-- | Alert
data Alert = Alert
  { alertLabels :: !((Map.Map String Text)) -- ^ /Required/ "labels"
  , alertGeneratorUrl :: !(Maybe Text) -- ^ "generatorURL"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Alert
instance A.FromJSON Alert where
  parseJSON = A.withObject "Alert" $ \o ->
    Alert
      <$> (o .:  "labels")
      <*> (o .:? "generatorURL")

-- | ToJSON Alert
instance A.ToJSON Alert where
  toJSON Alert {..} =
   _omitNulls
      [ "labels" .= alertLabels
      , "generatorURL" .= alertGeneratorUrl
      ]


-- | Construct a value of type 'Alert' (by applying it's required fields, if any)
mkAlert
  :: (Map.Map String Text) -- ^ 'alertLabels' 
  -> Alert
mkAlert alertLabels =
  Alert
  { alertLabels
  , alertGeneratorUrl = Nothing
  }

-- ** AlertGroup
-- | AlertGroup
data AlertGroup = AlertGroup
  { alertGroupLabels :: !((Map.Map String Text)) -- ^ /Required/ "labels"
  , alertGroupReceiver :: !(Receiver) -- ^ /Required/ "receiver"
  , alertGroupAlerts :: !([GettableAlert]) -- ^ /Required/ "alerts"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertGroup
instance A.FromJSON AlertGroup where
  parseJSON = A.withObject "AlertGroup" $ \o ->
    AlertGroup
      <$> (o .:  "labels")
      <*> (o .:  "receiver")
      <*> (o .:  "alerts")

-- | ToJSON AlertGroup
instance A.ToJSON AlertGroup where
  toJSON AlertGroup {..} =
   _omitNulls
      [ "labels" .= alertGroupLabels
      , "receiver" .= alertGroupReceiver
      , "alerts" .= alertGroupAlerts
      ]


-- | Construct a value of type 'AlertGroup' (by applying it's required fields, if any)
mkAlertGroup
  :: (Map.Map String Text) -- ^ 'alertGroupLabels' 
  -> Receiver -- ^ 'alertGroupReceiver' 
  -> [GettableAlert] -- ^ 'alertGroupAlerts' 
  -> AlertGroup
mkAlertGroup alertGroupLabels alertGroupReceiver alertGroupAlerts =
  AlertGroup
  { alertGroupLabels
  , alertGroupReceiver
  , alertGroupAlerts
  }

-- ** AlertStatus
-- | AlertStatus
data AlertStatus = AlertStatus
  { alertStatusState :: !(E'State2) -- ^ /Required/ "state"
  , alertStatusSilencedBy :: !([Text]) -- ^ /Required/ "silencedBy"
  , alertStatusInhibitedBy :: !([Text]) -- ^ /Required/ "inhibitedBy"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertStatus
instance A.FromJSON AlertStatus where
  parseJSON = A.withObject "AlertStatus" $ \o ->
    AlertStatus
      <$> (o .:  "state")
      <*> (o .:  "silencedBy")
      <*> (o .:  "inhibitedBy")

-- | ToJSON AlertStatus
instance A.ToJSON AlertStatus where
  toJSON AlertStatus {..} =
   _omitNulls
      [ "state" .= alertStatusState
      , "silencedBy" .= alertStatusSilencedBy
      , "inhibitedBy" .= alertStatusInhibitedBy
      ]


-- | Construct a value of type 'AlertStatus' (by applying it's required fields, if any)
mkAlertStatus
  :: E'State2 -- ^ 'alertStatusState' 
  -> [Text] -- ^ 'alertStatusSilencedBy' 
  -> [Text] -- ^ 'alertStatusInhibitedBy' 
  -> AlertStatus
mkAlertStatus alertStatusState alertStatusSilencedBy alertStatusInhibitedBy =
  AlertStatus
  { alertStatusState
  , alertStatusSilencedBy
  , alertStatusInhibitedBy
  }

-- ** AlertmanagerConfig
-- | AlertmanagerConfig
data AlertmanagerConfig = AlertmanagerConfig
  { alertmanagerConfigOriginal :: !(Text) -- ^ /Required/ "original"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertmanagerConfig
instance A.FromJSON AlertmanagerConfig where
  parseJSON = A.withObject "AlertmanagerConfig" $ \o ->
    AlertmanagerConfig
      <$> (o .:  "original")

-- | ToJSON AlertmanagerConfig
instance A.ToJSON AlertmanagerConfig where
  toJSON AlertmanagerConfig {..} =
   _omitNulls
      [ "original" .= alertmanagerConfigOriginal
      ]


-- | Construct a value of type 'AlertmanagerConfig' (by applying it's required fields, if any)
mkAlertmanagerConfig
  :: Text -- ^ 'alertmanagerConfigOriginal' 
  -> AlertmanagerConfig
mkAlertmanagerConfig alertmanagerConfigOriginal =
  AlertmanagerConfig
  { alertmanagerConfigOriginal
  }

-- ** AlertmanagerStatus
-- | AlertmanagerStatus
data AlertmanagerStatus = AlertmanagerStatus
  { alertmanagerStatusCluster :: !(ClusterStatus) -- ^ /Required/ "cluster"
  , alertmanagerStatusVersionInfo :: !(VersionInfo) -- ^ /Required/ "versionInfo"
  , alertmanagerStatusConfig :: !(AlertmanagerConfig) -- ^ /Required/ "config"
  , alertmanagerStatusUptime :: !(DateTime) -- ^ /Required/ "uptime"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AlertmanagerStatus
instance A.FromJSON AlertmanagerStatus where
  parseJSON = A.withObject "AlertmanagerStatus" $ \o ->
    AlertmanagerStatus
      <$> (o .:  "cluster")
      <*> (o .:  "versionInfo")
      <*> (o .:  "config")
      <*> (o .:  "uptime")

-- | ToJSON AlertmanagerStatus
instance A.ToJSON AlertmanagerStatus where
  toJSON AlertmanagerStatus {..} =
   _omitNulls
      [ "cluster" .= alertmanagerStatusCluster
      , "versionInfo" .= alertmanagerStatusVersionInfo
      , "config" .= alertmanagerStatusConfig
      , "uptime" .= alertmanagerStatusUptime
      ]


-- | Construct a value of type 'AlertmanagerStatus' (by applying it's required fields, if any)
mkAlertmanagerStatus
  :: ClusterStatus -- ^ 'alertmanagerStatusCluster' 
  -> VersionInfo -- ^ 'alertmanagerStatusVersionInfo' 
  -> AlertmanagerConfig -- ^ 'alertmanagerStatusConfig' 
  -> DateTime -- ^ 'alertmanagerStatusUptime' 
  -> AlertmanagerStatus
mkAlertmanagerStatus alertmanagerStatusCluster alertmanagerStatusVersionInfo alertmanagerStatusConfig alertmanagerStatusUptime =
  AlertmanagerStatus
  { alertmanagerStatusCluster
  , alertmanagerStatusVersionInfo
  , alertmanagerStatusConfig
  , alertmanagerStatusUptime
  }

-- ** ClusterStatus
-- | ClusterStatus
data ClusterStatus = ClusterStatus
  { clusterStatusName :: !(Maybe Text) -- ^ "name"
  , clusterStatusStatus :: !(E'Status) -- ^ /Required/ "status"
  , clusterStatusPeers :: !(Maybe [PeerStatus]) -- ^ "peers"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClusterStatus
instance A.FromJSON ClusterStatus where
  parseJSON = A.withObject "ClusterStatus" $ \o ->
    ClusterStatus
      <$> (o .:? "name")
      <*> (o .:  "status")
      <*> (o .:? "peers")

-- | ToJSON ClusterStatus
instance A.ToJSON ClusterStatus where
  toJSON ClusterStatus {..} =
   _omitNulls
      [ "name" .= clusterStatusName
      , "status" .= clusterStatusStatus
      , "peers" .= clusterStatusPeers
      ]


-- | Construct a value of type 'ClusterStatus' (by applying it's required fields, if any)
mkClusterStatus
  :: E'Status -- ^ 'clusterStatusStatus' 
  -> ClusterStatus
mkClusterStatus clusterStatusStatus =
  ClusterStatus
  { clusterStatusName = Nothing
  , clusterStatusStatus
  , clusterStatusPeers = Nothing
  }

-- ** GettableAlert
-- | GettableAlert
data GettableAlert = GettableAlert
  { gettableAlertAnnotations :: !((Map.Map String Text)) -- ^ /Required/ "annotations"
  , gettableAlertReceivers :: !([Receiver]) -- ^ /Required/ "receivers"
  , gettableAlertFingerprint :: !(Text) -- ^ /Required/ "fingerprint"
  , gettableAlertStartsAt :: !(DateTime) -- ^ /Required/ "startsAt"
  , gettableAlertUpdatedAt :: !(DateTime) -- ^ /Required/ "updatedAt"
  , gettableAlertEndsAt :: !(DateTime) -- ^ /Required/ "endsAt"
  , gettableAlertStatus :: !(AlertStatus) -- ^ /Required/ "status"
  , gettableAlertLabels :: !((Map.Map String Text)) -- ^ /Required/ "labels"
  , gettableAlertGeneratorUrl :: !(Maybe Text) -- ^ "generatorURL"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GettableAlert
instance A.FromJSON GettableAlert where
  parseJSON = A.withObject "GettableAlert" $ \o ->
    GettableAlert
      <$> (o .:  "annotations")
      <*> (o .:  "receivers")
      <*> (o .:  "fingerprint")
      <*> (o .:  "startsAt")
      <*> (o .:  "updatedAt")
      <*> (o .:  "endsAt")
      <*> (o .:  "status")
      <*> (o .:  "labels")
      <*> (o .:? "generatorURL")

-- | ToJSON GettableAlert
instance A.ToJSON GettableAlert where
  toJSON GettableAlert {..} =
   _omitNulls
      [ "annotations" .= gettableAlertAnnotations
      , "receivers" .= gettableAlertReceivers
      , "fingerprint" .= gettableAlertFingerprint
      , "startsAt" .= gettableAlertStartsAt
      , "updatedAt" .= gettableAlertUpdatedAt
      , "endsAt" .= gettableAlertEndsAt
      , "status" .= gettableAlertStatus
      , "labels" .= gettableAlertLabels
      , "generatorURL" .= gettableAlertGeneratorUrl
      ]


-- | Construct a value of type 'GettableAlert' (by applying it's required fields, if any)
mkGettableAlert
  :: (Map.Map String Text) -- ^ 'gettableAlertAnnotations' 
  -> [Receiver] -- ^ 'gettableAlertReceivers' 
  -> Text -- ^ 'gettableAlertFingerprint' 
  -> DateTime -- ^ 'gettableAlertStartsAt' 
  -> DateTime -- ^ 'gettableAlertUpdatedAt' 
  -> DateTime -- ^ 'gettableAlertEndsAt' 
  -> AlertStatus -- ^ 'gettableAlertStatus' 
  -> (Map.Map String Text) -- ^ 'gettableAlertLabels' 
  -> GettableAlert
mkGettableAlert gettableAlertAnnotations gettableAlertReceivers gettableAlertFingerprint gettableAlertStartsAt gettableAlertUpdatedAt gettableAlertEndsAt gettableAlertStatus gettableAlertLabels =
  GettableAlert
  { gettableAlertAnnotations
  , gettableAlertReceivers
  , gettableAlertFingerprint
  , gettableAlertStartsAt
  , gettableAlertUpdatedAt
  , gettableAlertEndsAt
  , gettableAlertStatus
  , gettableAlertLabels
  , gettableAlertGeneratorUrl = Nothing
  }

-- ** GettableAlertAllOf
-- | GettableAlertAllOf
data GettableAlertAllOf = GettableAlertAllOf
  { gettableAlertAllOfAnnotations :: !((Map.Map String Text)) -- ^ /Required/ "annotations"
  , gettableAlertAllOfReceivers :: !([Receiver]) -- ^ /Required/ "receivers"
  , gettableAlertAllOfFingerprint :: !(Text) -- ^ /Required/ "fingerprint"
  , gettableAlertAllOfStartsAt :: !(DateTime) -- ^ /Required/ "startsAt"
  , gettableAlertAllOfUpdatedAt :: !(DateTime) -- ^ /Required/ "updatedAt"
  , gettableAlertAllOfEndsAt :: !(DateTime) -- ^ /Required/ "endsAt"
  , gettableAlertAllOfStatus :: !(AlertStatus) -- ^ /Required/ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GettableAlertAllOf
instance A.FromJSON GettableAlertAllOf where
  parseJSON = A.withObject "GettableAlertAllOf" $ \o ->
    GettableAlertAllOf
      <$> (o .:  "annotations")
      <*> (o .:  "receivers")
      <*> (o .:  "fingerprint")
      <*> (o .:  "startsAt")
      <*> (o .:  "updatedAt")
      <*> (o .:  "endsAt")
      <*> (o .:  "status")

-- | ToJSON GettableAlertAllOf
instance A.ToJSON GettableAlertAllOf where
  toJSON GettableAlertAllOf {..} =
   _omitNulls
      [ "annotations" .= gettableAlertAllOfAnnotations
      , "receivers" .= gettableAlertAllOfReceivers
      , "fingerprint" .= gettableAlertAllOfFingerprint
      , "startsAt" .= gettableAlertAllOfStartsAt
      , "updatedAt" .= gettableAlertAllOfUpdatedAt
      , "endsAt" .= gettableAlertAllOfEndsAt
      , "status" .= gettableAlertAllOfStatus
      ]


-- | Construct a value of type 'GettableAlertAllOf' (by applying it's required fields, if any)
mkGettableAlertAllOf
  :: (Map.Map String Text) -- ^ 'gettableAlertAllOfAnnotations' 
  -> [Receiver] -- ^ 'gettableAlertAllOfReceivers' 
  -> Text -- ^ 'gettableAlertAllOfFingerprint' 
  -> DateTime -- ^ 'gettableAlertAllOfStartsAt' 
  -> DateTime -- ^ 'gettableAlertAllOfUpdatedAt' 
  -> DateTime -- ^ 'gettableAlertAllOfEndsAt' 
  -> AlertStatus -- ^ 'gettableAlertAllOfStatus' 
  -> GettableAlertAllOf
mkGettableAlertAllOf gettableAlertAllOfAnnotations gettableAlertAllOfReceivers gettableAlertAllOfFingerprint gettableAlertAllOfStartsAt gettableAlertAllOfUpdatedAt gettableAlertAllOfEndsAt gettableAlertAllOfStatus =
  GettableAlertAllOf
  { gettableAlertAllOfAnnotations
  , gettableAlertAllOfReceivers
  , gettableAlertAllOfFingerprint
  , gettableAlertAllOfStartsAt
  , gettableAlertAllOfUpdatedAt
  , gettableAlertAllOfEndsAt
  , gettableAlertAllOfStatus
  }

-- ** GettableSilence
-- | GettableSilence
data GettableSilence = GettableSilence
  { gettableSilenceId :: !(Text) -- ^ /Required/ "id"
  , gettableSilenceStatus :: !(SilenceStatus) -- ^ /Required/ "status"
  , gettableSilenceUpdatedAt :: !(DateTime) -- ^ /Required/ "updatedAt"
  , gettableSilenceMatchers :: !([Matcher]) -- ^ /Required/ "matchers"
  , gettableSilenceStartsAt :: !(DateTime) -- ^ /Required/ "startsAt"
  , gettableSilenceEndsAt :: !(DateTime) -- ^ /Required/ "endsAt"
  , gettableSilenceCreatedBy :: !(Text) -- ^ /Required/ "createdBy"
  , gettableSilenceComment :: !(Text) -- ^ /Required/ "comment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GettableSilence
instance A.FromJSON GettableSilence where
  parseJSON = A.withObject "GettableSilence" $ \o ->
    GettableSilence
      <$> (o .:  "id")
      <*> (o .:  "status")
      <*> (o .:  "updatedAt")
      <*> (o .:  "matchers")
      <*> (o .:  "startsAt")
      <*> (o .:  "endsAt")
      <*> (o .:  "createdBy")
      <*> (o .:  "comment")

-- | ToJSON GettableSilence
instance A.ToJSON GettableSilence where
  toJSON GettableSilence {..} =
   _omitNulls
      [ "id" .= gettableSilenceId
      , "status" .= gettableSilenceStatus
      , "updatedAt" .= gettableSilenceUpdatedAt
      , "matchers" .= gettableSilenceMatchers
      , "startsAt" .= gettableSilenceStartsAt
      , "endsAt" .= gettableSilenceEndsAt
      , "createdBy" .= gettableSilenceCreatedBy
      , "comment" .= gettableSilenceComment
      ]


-- | Construct a value of type 'GettableSilence' (by applying it's required fields, if any)
mkGettableSilence
  :: Text -- ^ 'gettableSilenceId' 
  -> SilenceStatus -- ^ 'gettableSilenceStatus' 
  -> DateTime -- ^ 'gettableSilenceUpdatedAt' 
  -> [Matcher] -- ^ 'gettableSilenceMatchers' 
  -> DateTime -- ^ 'gettableSilenceStartsAt' 
  -> DateTime -- ^ 'gettableSilenceEndsAt' 
  -> Text -- ^ 'gettableSilenceCreatedBy' 
  -> Text -- ^ 'gettableSilenceComment' 
  -> GettableSilence
mkGettableSilence gettableSilenceId gettableSilenceStatus gettableSilenceUpdatedAt gettableSilenceMatchers gettableSilenceStartsAt gettableSilenceEndsAt gettableSilenceCreatedBy gettableSilenceComment =
  GettableSilence
  { gettableSilenceId
  , gettableSilenceStatus
  , gettableSilenceUpdatedAt
  , gettableSilenceMatchers
  , gettableSilenceStartsAt
  , gettableSilenceEndsAt
  , gettableSilenceCreatedBy
  , gettableSilenceComment
  }

-- ** GettableSilenceAllOf
-- | GettableSilenceAllOf
data GettableSilenceAllOf = GettableSilenceAllOf
  { gettableSilenceAllOfId :: !(Text) -- ^ /Required/ "id"
  , gettableSilenceAllOfStatus :: !(SilenceStatus) -- ^ /Required/ "status"
  , gettableSilenceAllOfUpdatedAt :: !(DateTime) -- ^ /Required/ "updatedAt"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GettableSilenceAllOf
instance A.FromJSON GettableSilenceAllOf where
  parseJSON = A.withObject "GettableSilenceAllOf" $ \o ->
    GettableSilenceAllOf
      <$> (o .:  "id")
      <*> (o .:  "status")
      <*> (o .:  "updatedAt")

-- | ToJSON GettableSilenceAllOf
instance A.ToJSON GettableSilenceAllOf where
  toJSON GettableSilenceAllOf {..} =
   _omitNulls
      [ "id" .= gettableSilenceAllOfId
      , "status" .= gettableSilenceAllOfStatus
      , "updatedAt" .= gettableSilenceAllOfUpdatedAt
      ]


-- | Construct a value of type 'GettableSilenceAllOf' (by applying it's required fields, if any)
mkGettableSilenceAllOf
  :: Text -- ^ 'gettableSilenceAllOfId' 
  -> SilenceStatus -- ^ 'gettableSilenceAllOfStatus' 
  -> DateTime -- ^ 'gettableSilenceAllOfUpdatedAt' 
  -> GettableSilenceAllOf
mkGettableSilenceAllOf gettableSilenceAllOfId gettableSilenceAllOfStatus gettableSilenceAllOfUpdatedAt =
  GettableSilenceAllOf
  { gettableSilenceAllOfId
  , gettableSilenceAllOfStatus
  , gettableSilenceAllOfUpdatedAt
  }

-- ** InlineResponse200
-- | InlineResponse200
data InlineResponse200 = InlineResponse200
  { inlineResponse200SilenceId :: !(Maybe Text) -- ^ "silenceID"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse200
instance A.FromJSON InlineResponse200 where
  parseJSON = A.withObject "InlineResponse200" $ \o ->
    InlineResponse200
      <$> (o .:? "silenceID")

-- | ToJSON InlineResponse200
instance A.ToJSON InlineResponse200 where
  toJSON InlineResponse200 {..} =
   _omitNulls
      [ "silenceID" .= inlineResponse200SilenceId
      ]


-- | Construct a value of type 'InlineResponse200' (by applying it's required fields, if any)
mkInlineResponse200
  :: InlineResponse200
mkInlineResponse200 =
  InlineResponse200
  { inlineResponse200SilenceId = Nothing
  }

-- ** Matcher
-- | Matcher
data Matcher = Matcher
  { matcherName :: !(Text) -- ^ /Required/ "name"
  , matcherValue :: !(Text) -- ^ /Required/ "value"
  , matcherIsRegex :: !(Bool) -- ^ /Required/ "isRegex"
  , matcherIsEqual :: !(Maybe Bool) -- ^ "isEqual"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Matcher
instance A.FromJSON Matcher where
  parseJSON = A.withObject "Matcher" $ \o ->
    Matcher
      <$> (o .:  "name")
      <*> (o .:  "value")
      <*> (o .:  "isRegex")
      <*> (o .:? "isEqual")

-- | ToJSON Matcher
instance A.ToJSON Matcher where
  toJSON Matcher {..} =
   _omitNulls
      [ "name" .= matcherName
      , "value" .= matcherValue
      , "isRegex" .= matcherIsRegex
      , "isEqual" .= matcherIsEqual
      ]


-- | Construct a value of type 'Matcher' (by applying it's required fields, if any)
mkMatcher
  :: Text -- ^ 'matcherName' 
  -> Text -- ^ 'matcherValue' 
  -> Bool -- ^ 'matcherIsRegex' 
  -> Matcher
mkMatcher matcherName matcherValue matcherIsRegex =
  Matcher
  { matcherName
  , matcherValue
  , matcherIsRegex
  , matcherIsEqual = Nothing
  }

-- ** PeerStatus
-- | PeerStatus
data PeerStatus = PeerStatus
  { peerStatusName :: !(Text) -- ^ /Required/ "name"
  , peerStatusAddress :: !(Text) -- ^ /Required/ "address"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PeerStatus
instance A.FromJSON PeerStatus where
  parseJSON = A.withObject "PeerStatus" $ \o ->
    PeerStatus
      <$> (o .:  "name")
      <*> (o .:  "address")

-- | ToJSON PeerStatus
instance A.ToJSON PeerStatus where
  toJSON PeerStatus {..} =
   _omitNulls
      [ "name" .= peerStatusName
      , "address" .= peerStatusAddress
      ]


-- | Construct a value of type 'PeerStatus' (by applying it's required fields, if any)
mkPeerStatus
  :: Text -- ^ 'peerStatusName' 
  -> Text -- ^ 'peerStatusAddress' 
  -> PeerStatus
mkPeerStatus peerStatusName peerStatusAddress =
  PeerStatus
  { peerStatusName
  , peerStatusAddress
  }

-- ** PostableAlert
-- | PostableAlert
data PostableAlert = PostableAlert
  { postableAlertStartsAt :: !(Maybe DateTime) -- ^ "startsAt"
  , postableAlertEndsAt :: !(Maybe DateTime) -- ^ "endsAt"
  , postableAlertAnnotations :: !(Maybe (Map.Map String Text)) -- ^ "annotations"
  , postableAlertLabels :: !((Map.Map String Text)) -- ^ /Required/ "labels"
  , postableAlertGeneratorUrl :: !(Maybe Text) -- ^ "generatorURL"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PostableAlert
instance A.FromJSON PostableAlert where
  parseJSON = A.withObject "PostableAlert" $ \o ->
    PostableAlert
      <$> (o .:? "startsAt")
      <*> (o .:? "endsAt")
      <*> (o .:? "annotations")
      <*> (o .:  "labels")
      <*> (o .:? "generatorURL")

-- | ToJSON PostableAlert
instance A.ToJSON PostableAlert where
  toJSON PostableAlert {..} =
   _omitNulls
      [ "startsAt" .= postableAlertStartsAt
      , "endsAt" .= postableAlertEndsAt
      , "annotations" .= postableAlertAnnotations
      , "labels" .= postableAlertLabels
      , "generatorURL" .= postableAlertGeneratorUrl
      ]


-- | Construct a value of type 'PostableAlert' (by applying it's required fields, if any)
mkPostableAlert
  :: (Map.Map String Text) -- ^ 'postableAlertLabels' 
  -> PostableAlert
mkPostableAlert postableAlertLabels =
  PostableAlert
  { postableAlertStartsAt = Nothing
  , postableAlertEndsAt = Nothing
  , postableAlertAnnotations = Nothing
  , postableAlertLabels
  , postableAlertGeneratorUrl = Nothing
  }

-- ** PostableAlertAllOf
-- | PostableAlertAllOf
data PostableAlertAllOf = PostableAlertAllOf
  { postableAlertAllOfStartsAt :: !(Maybe DateTime) -- ^ "startsAt"
  , postableAlertAllOfEndsAt :: !(Maybe DateTime) -- ^ "endsAt"
  , postableAlertAllOfAnnotations :: !(Maybe (Map.Map String Text)) -- ^ "annotations"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PostableAlertAllOf
instance A.FromJSON PostableAlertAllOf where
  parseJSON = A.withObject "PostableAlertAllOf" $ \o ->
    PostableAlertAllOf
      <$> (o .:? "startsAt")
      <*> (o .:? "endsAt")
      <*> (o .:? "annotations")

-- | ToJSON PostableAlertAllOf
instance A.ToJSON PostableAlertAllOf where
  toJSON PostableAlertAllOf {..} =
   _omitNulls
      [ "startsAt" .= postableAlertAllOfStartsAt
      , "endsAt" .= postableAlertAllOfEndsAt
      , "annotations" .= postableAlertAllOfAnnotations
      ]


-- | Construct a value of type 'PostableAlertAllOf' (by applying it's required fields, if any)
mkPostableAlertAllOf
  :: PostableAlertAllOf
mkPostableAlertAllOf =
  PostableAlertAllOf
  { postableAlertAllOfStartsAt = Nothing
  , postableAlertAllOfEndsAt = Nothing
  , postableAlertAllOfAnnotations = Nothing
  }

-- ** PostableSilence
-- | PostableSilence
data PostableSilence = PostableSilence
  { postableSilenceId :: !(Maybe Text) -- ^ "id"
  , postableSilenceMatchers :: !([Matcher]) -- ^ /Required/ "matchers"
  , postableSilenceStartsAt :: !(DateTime) -- ^ /Required/ "startsAt"
  , postableSilenceEndsAt :: !(DateTime) -- ^ /Required/ "endsAt"
  , postableSilenceCreatedBy :: !(Text) -- ^ /Required/ "createdBy"
  , postableSilenceComment :: !(Text) -- ^ /Required/ "comment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PostableSilence
instance A.FromJSON PostableSilence where
  parseJSON = A.withObject "PostableSilence" $ \o ->
    PostableSilence
      <$> (o .:? "id")
      <*> (o .:  "matchers")
      <*> (o .:  "startsAt")
      <*> (o .:  "endsAt")
      <*> (o .:  "createdBy")
      <*> (o .:  "comment")

-- | ToJSON PostableSilence
instance A.ToJSON PostableSilence where
  toJSON PostableSilence {..} =
   _omitNulls
      [ "id" .= postableSilenceId
      , "matchers" .= postableSilenceMatchers
      , "startsAt" .= postableSilenceStartsAt
      , "endsAt" .= postableSilenceEndsAt
      , "createdBy" .= postableSilenceCreatedBy
      , "comment" .= postableSilenceComment
      ]


-- | Construct a value of type 'PostableSilence' (by applying it's required fields, if any)
mkPostableSilence
  :: [Matcher] -- ^ 'postableSilenceMatchers' 
  -> DateTime -- ^ 'postableSilenceStartsAt' 
  -> DateTime -- ^ 'postableSilenceEndsAt' 
  -> Text -- ^ 'postableSilenceCreatedBy' 
  -> Text -- ^ 'postableSilenceComment' 
  -> PostableSilence
mkPostableSilence postableSilenceMatchers postableSilenceStartsAt postableSilenceEndsAt postableSilenceCreatedBy postableSilenceComment =
  PostableSilence
  { postableSilenceId = Nothing
  , postableSilenceMatchers
  , postableSilenceStartsAt
  , postableSilenceEndsAt
  , postableSilenceCreatedBy
  , postableSilenceComment
  }

-- ** PostableSilenceAllOf
-- | PostableSilenceAllOf
data PostableSilenceAllOf = PostableSilenceAllOf
  { postableSilenceAllOfId :: !(Maybe Text) -- ^ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PostableSilenceAllOf
instance A.FromJSON PostableSilenceAllOf where
  parseJSON = A.withObject "PostableSilenceAllOf" $ \o ->
    PostableSilenceAllOf
      <$> (o .:? "id")

-- | ToJSON PostableSilenceAllOf
instance A.ToJSON PostableSilenceAllOf where
  toJSON PostableSilenceAllOf {..} =
   _omitNulls
      [ "id" .= postableSilenceAllOfId
      ]


-- | Construct a value of type 'PostableSilenceAllOf' (by applying it's required fields, if any)
mkPostableSilenceAllOf
  :: PostableSilenceAllOf
mkPostableSilenceAllOf =
  PostableSilenceAllOf
  { postableSilenceAllOfId = Nothing
  }

-- ** Receiver
-- | Receiver
data Receiver = Receiver
  { receiverName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Receiver
instance A.FromJSON Receiver where
  parseJSON = A.withObject "Receiver" $ \o ->
    Receiver
      <$> (o .:  "name")

-- | ToJSON Receiver
instance A.ToJSON Receiver where
  toJSON Receiver {..} =
   _omitNulls
      [ "name" .= receiverName
      ]


-- | Construct a value of type 'Receiver' (by applying it's required fields, if any)
mkReceiver
  :: Text -- ^ 'receiverName' 
  -> Receiver
mkReceiver receiverName =
  Receiver
  { receiverName
  }

-- ** Silence
-- | Silence
data Silence = Silence
  { silenceMatchers :: !([Matcher]) -- ^ /Required/ "matchers"
  , silenceStartsAt :: !(DateTime) -- ^ /Required/ "startsAt"
  , silenceEndsAt :: !(DateTime) -- ^ /Required/ "endsAt"
  , silenceCreatedBy :: !(Text) -- ^ /Required/ "createdBy"
  , silenceComment :: !(Text) -- ^ /Required/ "comment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Silence
instance A.FromJSON Silence where
  parseJSON = A.withObject "Silence" $ \o ->
    Silence
      <$> (o .:  "matchers")
      <*> (o .:  "startsAt")
      <*> (o .:  "endsAt")
      <*> (o .:  "createdBy")
      <*> (o .:  "comment")

-- | ToJSON Silence
instance A.ToJSON Silence where
  toJSON Silence {..} =
   _omitNulls
      [ "matchers" .= silenceMatchers
      , "startsAt" .= silenceStartsAt
      , "endsAt" .= silenceEndsAt
      , "createdBy" .= silenceCreatedBy
      , "comment" .= silenceComment
      ]


-- | Construct a value of type 'Silence' (by applying it's required fields, if any)
mkSilence
  :: [Matcher] -- ^ 'silenceMatchers' 
  -> DateTime -- ^ 'silenceStartsAt' 
  -> DateTime -- ^ 'silenceEndsAt' 
  -> Text -- ^ 'silenceCreatedBy' 
  -> Text -- ^ 'silenceComment' 
  -> Silence
mkSilence silenceMatchers silenceStartsAt silenceEndsAt silenceCreatedBy silenceComment =
  Silence
  { silenceMatchers
  , silenceStartsAt
  , silenceEndsAt
  , silenceCreatedBy
  , silenceComment
  }

-- ** SilenceStatus
-- | SilenceStatus
data SilenceStatus = SilenceStatus
  { silenceStatusState :: !(E'State) -- ^ /Required/ "state"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SilenceStatus
instance A.FromJSON SilenceStatus where
  parseJSON = A.withObject "SilenceStatus" $ \o ->
    SilenceStatus
      <$> (o .:  "state")

-- | ToJSON SilenceStatus
instance A.ToJSON SilenceStatus where
  toJSON SilenceStatus {..} =
   _omitNulls
      [ "state" .= silenceStatusState
      ]


-- | Construct a value of type 'SilenceStatus' (by applying it's required fields, if any)
mkSilenceStatus
  :: E'State -- ^ 'silenceStatusState' 
  -> SilenceStatus
mkSilenceStatus silenceStatusState =
  SilenceStatus
  { silenceStatusState
  }

-- ** VersionInfo
-- | VersionInfo
data VersionInfo = VersionInfo
  { versionInfoVersion :: !(Text) -- ^ /Required/ "version"
  , versionInfoRevision :: !(Text) -- ^ /Required/ "revision"
  , versionInfoBranch :: !(Text) -- ^ /Required/ "branch"
  , versionInfoBuildUser :: !(Text) -- ^ /Required/ "buildUser"
  , versionInfoBuildDate :: !(Text) -- ^ /Required/ "buildDate"
  , versionInfoGoVersion :: !(Text) -- ^ /Required/ "goVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VersionInfo
instance A.FromJSON VersionInfo where
  parseJSON = A.withObject "VersionInfo" $ \o ->
    VersionInfo
      <$> (o .:  "version")
      <*> (o .:  "revision")
      <*> (o .:  "branch")
      <*> (o .:  "buildUser")
      <*> (o .:  "buildDate")
      <*> (o .:  "goVersion")

-- | ToJSON VersionInfo
instance A.ToJSON VersionInfo where
  toJSON VersionInfo {..} =
   _omitNulls
      [ "version" .= versionInfoVersion
      , "revision" .= versionInfoRevision
      , "branch" .= versionInfoBranch
      , "buildUser" .= versionInfoBuildUser
      , "buildDate" .= versionInfoBuildDate
      , "goVersion" .= versionInfoGoVersion
      ]


-- | Construct a value of type 'VersionInfo' (by applying it's required fields, if any)
mkVersionInfo
  :: Text -- ^ 'versionInfoVersion' 
  -> Text -- ^ 'versionInfoRevision' 
  -> Text -- ^ 'versionInfoBranch' 
  -> Text -- ^ 'versionInfoBuildUser' 
  -> Text -- ^ 'versionInfoBuildDate' 
  -> Text -- ^ 'versionInfoGoVersion' 
  -> VersionInfo
mkVersionInfo versionInfoVersion versionInfoRevision versionInfoBranch versionInfoBuildUser versionInfoBuildDate versionInfoGoVersion =
  VersionInfo
  { versionInfoVersion
  , versionInfoRevision
  , versionInfoBranch
  , versionInfoBuildUser
  , versionInfoBuildDate
  , versionInfoGoVersion
  }


-- * Enums


-- ** E'State

-- | Enum of 'Text'
data E'State
  = E'State'Expired -- ^ @"expired"@
  | E'State'Active -- ^ @"active"@
  | E'State'Pending -- ^ @"pending"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State where toJSON = A.toJSON . fromE'State
instance A.FromJSON E'State where parseJSON o = P.either P.fail (pure . P.id) . toE'State =<< A.parseJSON o
instance WH.ToHttpApiData E'State where toQueryParam = WH.toQueryParam . fromE'State
instance WH.FromHttpApiData E'State where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State
instance MimeRender MimeMultipartFormData E'State where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State' enum
fromE'State :: E'State -> Text
fromE'State = \case
  E'State'Expired -> "expired"
  E'State'Active -> "active"
  E'State'Pending -> "pending"

-- | parse 'E'State' enum
toE'State :: Text -> P.Either String E'State
toE'State = \case
  "expired" -> P.Right E'State'Expired
  "active" -> P.Right E'State'Active
  "pending" -> P.Right E'State'Pending
  s -> P.Left $ "toE'State: enum parse failure: " P.++ P.show s


-- ** E'State2

-- | Enum of 'Text'
data E'State2
  = E'State2'Unprocessed -- ^ @"unprocessed"@
  | E'State2'Active -- ^ @"active"@
  | E'State2'Suppressed -- ^ @"suppressed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State2 where toJSON = A.toJSON . fromE'State2
instance A.FromJSON E'State2 where parseJSON o = P.either P.fail (pure . P.id) . toE'State2 =<< A.parseJSON o
instance WH.ToHttpApiData E'State2 where toQueryParam = WH.toQueryParam . fromE'State2
instance WH.FromHttpApiData E'State2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State2
instance MimeRender MimeMultipartFormData E'State2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State2' enum
fromE'State2 :: E'State2 -> Text
fromE'State2 = \case
  E'State2'Unprocessed -> "unprocessed"
  E'State2'Active -> "active"
  E'State2'Suppressed -> "suppressed"

-- | parse 'E'State2' enum
toE'State2 :: Text -> P.Either String E'State2
toE'State2 = \case
  "unprocessed" -> P.Right E'State2'Unprocessed
  "active" -> P.Right E'State2'Active
  "suppressed" -> P.Right E'State2'Suppressed
  s -> P.Left $ "toE'State2: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text'
data E'Status
  = E'Status'Ready -- ^ @"ready"@
  | E'Status'Settling -- ^ @"settling"@
  | E'Status'Disabled -- ^ @"disabled"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'Ready -> "ready"
  E'Status'Settling -> "settling"
  E'Status'Disabled -> "disabled"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "ready" -> P.Right E'Status'Ready
  "settling" -> P.Right E'Status'Settling
  "disabled" -> P.Right E'Status'Disabled
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s



